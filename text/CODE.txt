TASK 1

Write a program to display the following on separate lines using the WRITE statement:
•	First Name: …
•	Last Name: …
•	Birthdate: …
•	Hobby: …
Place your mouse on WRITE statement in Eclipse and press F1 for help.


ANSWER 

WRITE: '***********************' .
SKIP 1 .
WRITE: 'First Name:' ,' ' ,'Elif' ,
    / 'Last Name:' , '  ' ,'Bicer' ,
    / 'Birthday:' , '   ' ,'09.03.1997' ,
    / 'Hobby:' ,  '      ' , 'Driving' .
SKIP 2 .
WRITE '************************' .







TASK 2


Modify your previous program using text symbols.
Bonus: Try out translations. 
Example:
 
To get to text symbol maintenance:
Right click on the code in Eclipse -> Open Others -> Text Symbols

ANSWER

WRITE: '***********************' .
SKIP 1 .
WRITE: TEXT-001, 'ELIF',
    / TEXT-002, 'BICER',
    / TEXT-003, '09.03.1997',
    / TEXT-004,'DRIVING'.
SKIP 2 .
WRITE '************************' .






TASK 3

Modify previous program add following information using system variables:
•	User Name
•	User Local Time
•	User Local Date
•	SAP Logon Language Key


ANSWER

WRITE: '***********************' .
SKIP 1 .
WRITE: 'User Name: ', sy-uname ,
    /'User Local Time: ', sy-timlo ,
    /'User Local Date: ', sy-datlo ,
    /'SAP Logon Language Key: ', sy-langu .

SKIP 2 .
WRITE '************************' .








TASK 4

Modify your previous program using string templates.
Example:
 


ANSWER
WRITE: |String template is onclosed in 'pipes'|, /
       |'Username: { sy-uname }'|, /
       |'Dream Salary: ' { reverse(  text-005 ) } | .

TOPIC2 SLIDE:13


*** Constants ***
CONSTANTS: lc_uni1 TYPE c LENGTH 3 VALUE 'RTU',
           lc_uni2 TYPE c VALUE 'LU', "<--- what is wrong with this declaration? ADD LENGTH 2 VALUE ‘LU’
           lc_num1 TYPE i VALUE 3000.
           
           lc_num1 = lc_num1 + 1. "<--- what is wrong here?
           lc_num1 = 3001. "<--- is this right?

CORRECT CODE:
DATA: lv_num1 TYPE i.
Lv_num1 = lc_num1.
lv_num1 = lv_num1+1.
TASK 5

Modify your previous program from ‘Simple Output Statements’ by adding variables and constants.
•	Declare variables, use correct data types.
•	Think of a new field where you could use a constant.
•	Try both inline and regular declarations.
•	Fill the variables with values.
•	Display the data in a meaningful way with ‘WRITE’.

ANSWER

DATA: gv_name TYPE string,
             gv_age  TYPE i,
             gv_city TYPE string.

CONSTANTS: gc_country TYPE string VALUE 'Turkey'.

DATA(gv_greeting) = 'Hello'.
DATA(gv_question) = |How are you?| .
gv_name = 'Elif'.
gv_age = 27.
gv_city = 'Riga'.
WRITE: / 'Greeting:', gv_greeting,
    / 'Question:', gv_question,
     / 'Name:', gv_name,
       / 'Age:', gv_age,
       / 'City:', gv_city,
       / 'Country:', gc_country.
















TASK 6

Modify previous program.
•	Create a structured data type.
•	Declare an internal structure.
•	Fill the internal structure fields with values.
•	Display the data in a meaningful way with ‘WRITE’.

ANSWER
TYPES: BEGIN OF ty_person,
         name TYPE string,
         age  TYPE i,
         city TYPE string,
       END OF ty_person.
DATA: person TYPE ty_person.
person-name = 'Elif Bicer'.
person-age  = 27.
person-city = 'Riga'.
WRITE: / 'Name:', person-name,
       / 'Age:', person-age,
       / 'City:', person-city.







TASK 7

Using previous program:
	Create new structure with fields Date, Month and Year pass the data from Birthdate to these fields.
	Create new field ID in structure, which will have concatenated first letters of First Name and Last Name.
	Display the data in a meaningful way with ‘WRITE’.
 


TYPES: BEGIN OF ty_person,
         first_name TYPE string,
         last_name  TYPE string,
         birthdate  TYPE d,       " Date format
         date(2)       TYPE c,
         month(2)      TYPE c,
         year(4)       TYPE c,
         id         TYPE string,
       END OF ty_person.

DATA: lv_person TYPE ty_person.

lv_person-first_name = 'Elif'.
lv_person-last_name  = 'Bicer'.
lv_person-birthdate  = '19970309'.  " Format YYYYMMDD

lv_person-date = lv_person-birthdate+6(2).
lv_person-month = lv_person-birthdate+4(2).
lv_person-year = lv_person-birthdate+0(4).

lv_person-id = lv_person-first_name+0(1) && lv_person-last_name+0(1).

WRITE: / 'First Name: ', lv_person-first_name,
       / 'Last Name: ', lv_person-last_name,
       / 'Birthdate: ', lv_person-date, '-', lv_person-month, '-', lv_person-year,
       / 'ID: ', lv_person-id.


















TASK  8


Create a simple calculator program.
•	Two input parameters to accept numbers.
•	Logic to add those two numbers and display the result in a meaningful way using ‘WRITE’.
 

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-001.
PARAMETERS: p_num1 TYPE i,
            p_num2 TYPE i.
SELECTION-SCREEN END OF BLOCK b1.

  DATA: result TYPE i.
  result = p_num1 + p_num2.
  WRITE: / 'First Number:' , p_num1 ,
         / 'Second Number:' , p_num2 ,
         / 'Sum: ', result.




Task8\2


SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-001.
PARAMETERS: p_num1 TYPE i,
            p_num2 TYPE i,
            cb_1 AS CHECKBOX,
            rb_1 RADIOBUTTON GROUP g1,
            rb_2 RADIOBUTTON GROUP g1.
SELECTION-SCREEN END OF BLOCK b1.

  DATA: result TYPE i.
  result = p_num1 + p_num2.
  WRITE: / 'First Number: ', 11 ,
         / 'Second Number: ', 14 ,
         / 'Sum: ', result.


TASK 9

Modify your calculator program.
•	Two input parameters to accept numbers.
•	Radio buttons for arithmetical operations
•	Logic for the calculating and displaying the result (yes – in a meaningful way)
Logic based on a CASE statement


ANSWER
DATA: lv_number1 TYPE p DECIMALS 2,
      lv_number2 TYPE p DECIMALS 2,
      lv_result  TYPE p DECIMALS 2.

PARAMETERS: p_num1 TYPE p DECIMALS 2,
            p_num2 TYPE p DECIMALS 2.

SELECTION-SCREEN BEGIN OF BLOCK operations WITH FRAME TITLE text-001.
PARAMETERS: rb_add  RADIOBUTTON GROUP rbg DEFAULT 'X',
            rb_sub  RADIOBUTTON GROUP rbg,
            rb_mul  RADIOBUTTON GROUP rbg,
            rb_div  RADIOBUTTON GROUP rbg.
SELECTION-SCREEN END OF BLOCK operations.

INITIALIZATION.
  lv_number1 = p_num1.
  lv_number2 = p_num2.

START-OF-SELECTION.
  PERFORM calculate USING lv_number1 lv_number2.

FORM calculate USING p1 TYPE p
                     p2 TYPE p.
  CASE 'X'.
    WHEN rb_add.
      lv_result = p1 + p2.
      WRITE: / 'Result:', p1, ' + ', p2, ' = ', lv_result.
    WHEN rb_sub.
      lv_result = p1 - p2.
      WRITE: / 'Result:', p1, ' - ', p2, ' = ', lv_result.
    WHEN rb_mul.
      lv_result = p1 * p2.
      WRITE: / 'Result:', p1, ' * ', p2, ' = ', lv_result.
    WHEN rb_div.
      IF p2 = 0.
        WRITE: / 'Error: Division by zero'.
      ELSE.
        lv_result = p1 / p2.
        WRITE: / 'Result:', p1, ' / ', p2, ' = ', lv_result.
      ENDIF.
  ENDCASE.
ENDFORM.





TASK 9


Modify your calculator program.
•	Determine if the result of the operation is even or odd number.
•	Use CASE-ENDCASE branches to WRITE if the result was an even or an odd number.


ANSWER
DATA: lv_number1 TYPE p DECIMALS 2,
      lv_number2 TYPE p DECIMALS 2,
      lv_result  TYPE p DECIMALS 2.

PARAMETERS: p_num1 TYPE p DECIMALS 2,
            p_num2 TYPE p DECIMALS 2.

SELECTION-SCREEN BEGIN OF BLOCK operations WITH FRAME TITLE text-001.
PARAMETERS: rb_add  RADIOBUTTON GROUP rbg DEFAULT 'X',
            rb_sub  RADIOBUTTON GROUP rbg,
            rb_mul  RADIOBUTTON GROUP rbg,
            rb_div  RADIOBUTTON GROUP rbg.
SELECTION-SCREEN END OF BLOCK operations.

INITIALIZATION.
  lv_number1 = p_num1.
  lv_number2 = p_num2.

START-OF-SELECTION.
  PERFORM calculate USING lv_number1 lv_number2.

FORM calculate USING p1 TYPE p
                     p2 TYPE p.
  CASE 'X'.
    WHEN rb_add.
      lv_result = p1 + p2.
      WRITE: / 'Result:', p1, ' + ', p2, ' = ', lv_result.
    WHEN rb_sub.
      lv_result = p1 - p2.
      WRITE: / 'Result:', p1, ' - ', p2, ' = ', lv_result.
    WHEN rb_mul.
      lv_result = p1 * p2.
      WRITE: / 'Result:', p1, ' * ', p2, ' = ', lv_result.
    WHEN rb_div.
      IF p2 = 0.
        WRITE: / 'Error: Division by zero'.
      ELSE.
        lv_result = p1 / p2.
        WRITE: / 'Result:', p1, ' / ', p2, ' = ', lv_result.
      ENDIF.
  ENDCASE.
  
  IF sy-subrc = 0 AND p2 <> 0.
    PERFORM check_even_odd USING lv_result.
  ENDIF.
ENDFORM.

FORM check_even_odd USING result TYPE p.
  DATA: lv_remainder TYPE i.

  lv_remainder = result MOD 2.

  CASE lv_remainder.
    WHEN 0.
      WRITE: / 'The result is an even number.'.
    WHEN 1.
      WRITE: / 'The result is an odd number.'.
  ENDCASE.
ENDFORM.


















TASK 10 

Create a program that works as follows:
•	Has two input parameters for integer numbers.
•	First number determines the number of loop iterations.
•	Second number sets the threshold to stop the loop earlier.
•	Output should show the number of the iterations made, but skip the even iterations.
•	Bonus: add logic after selection to make sure that Num2 is smaller than Num1 – else message

ANSWER

PARAMETERS: p_num1 TYPE i, " Number of loop iterations
            p_num2 TYPE i. " Threshold to stop the loop earlier

START-OF-SELECTION.
  PERFORM validate_input USING p_num1 p_num2.
  PERFORM execute_loop   USING p_num1 p_num2.

FORM validate_input USING num1 TYPE i
                          num2 TYPE i.
  IF num2 >= num1.
    MESSAGE 'Second number must be smaller than the first number.' TYPE 'E'.
    EXIT.
  ENDIF.
ENDFORM.

FORM execute_loop USING num1 TYPE i
                        num2 TYPE i.
  DATA: lv_counter TYPE i VALUE 0,
        lv_iterations TYPE i VALUE 0.

  DO num1 TIMES.
    lv_counter = lv_counter + 1.

    IF lv_counter > num2.
      EXIT.
    ENDIF.

    lv_iterations = lv_iterations + 1.

    IF lv_iterations MOD 2 = 0.
      CONTINUE.
    ENDIF.

    WRITE: / 'Iteration:', lv_iterations.
  ENDDO.

  WRITE: / 'Total iterations made:', lv_counter.
ENDFORM.




TASK 11

Modify your calculator program.
•	Display the relevant message when trying to divide by zero.
•	Force user to change the zero divider to something else.


ANSWER

DATA: lv_number1 TYPE p DECIMALS 2,
      lv_number2 TYPE p DECIMALS 2,
      lv_result  TYPE p DECIMALS 2.

PARAMETERS: p_num1 TYPE p DECIMALS 2,
            p_num2 TYPE p DECIMALS 2.

SELECTION-SCREEN BEGIN OF BLOCK operations WITH FRAME TITLE text-001.
PARAMETERS: rb_add  RADIOBUTTON GROUP rbg DEFAULT 'X',
            rb_sub  RADIOBUTTON GROUP rbg,
            rb_mul  RADIOBUTTON GROUP rbg,
            rb_div  RADIOBUTTON GROUP rbg.
SELECTION-SCREEN END OF BLOCK operations.

INITIALIZATION.
  lv_number1 = p_num1.
  lv_number2 = p_num2.

AT SELECTION-SCREEN.
  PERFORM validate_input USING p_num1 p_num2.

START-OF-SELECTION.
  PERFORM calculate USING lv_number1 lv_number2.

FORM validate_input USING num1 TYPE p
                          num2 TYPE p.
  IF rb_div = 'X' AND num2 = 0.
    MESSAGE 'Division by zero is not allowed. Please provide a non-zero divider.' TYPE 'E'.
  ENDIF.
ENDFORM.

FORM calculate USING p1 TYPE p
                     p2 TYPE p.
  CASE 'X'.
    WHEN rb_add.
      lv_result = p1 + p2.
      WRITE: / 'Result:', p1, ' + ', p2, ' = ', lv_result.
    WHEN rb_sub.
      lv_result = p1 - p2.
      WRITE: / 'Result:', p1, ' - ', p2, ' = ', lv_result.
    WHEN rb_mul.
      lv_result = p1 * p2.
      WRITE: / 'Result:', p1, ' * ', p2, ' = ', lv_result.
    WHEN rb_div.
      IF p2 = 0.
        WRITE: / 'Division by zero is not allowed. Please provide a non-zero divider.'.
        EXIT.
      ELSE.
        lv_result = p1 / p2.
        WRITE: / 'Result:', p1, ' / ', p2, ' = ', lv_result.
      ENDIF.
  ENDCASE.
  
  IF sy-subrc = 0 AND p2 <> 0.
    PERFORM check_even_odd USING lv_result.
  ENDIF.
ENDFORM.

FORM check_even_odd USING result TYPE p.
  DATA: lv_remainder TYPE i.

  lv_remainder = result MOD 2.

  CASE lv_remainder.
    WHEN 0.
      WRITE: / 'The result is an even number.'.
    WHEN 1.
      WRITE: / 'The result is an odd number.'.
  ENDCASE.
ENDFORM.



INTERNAL STRUCTURES


*&---------------------------------------------------------------------*
*& Report zinternal_steb
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zinternal_steb.
*** Internal Structures ***
*** Declaration using your own internal type ***
TYPES: BEGIN OF ty_person,
        fname(25) TYPE c,
        lname(25) TYPE c,
        dob       TYPE d,
        "... you get the idea ..."
       END OF ty_person.

DATA ls_person1 TYPE ty_person.
*** Internal Structures ***
*** Filling the internal structure with data
ls_person1-fname = 'Bob'.
ls_person1-lname = 'McBoss'.
ls_person1-dob   = sy-datum.

*** Filling the internal structure with data using inline declaration
DATA(ls_person2) = VALUE ty_person( fname = 'Alice'
                                    lname = 'Doe'
                                    dob   = sy-datum ).

*** Internal Structures ***
*** Declaration using DDIC types ***
DATA ls_delivery1 TYPE likp.

*** Filling the internal structure with data
ls_delivery1-vbeln = '999888777'.
ls_delivery1-ernam = 'Alice'.
ls_delivery1-erzet = sy-uzeit.
".........."

*** Filling the internal structure with data using inline declaration
DATA(ls_delivery2) = VALUE likp( vbeln = '111222333'
                                 ernam = 'Bob'
                                 erzet = sy-uzeit
                                 "..............."
                                   ).






INTERNAL  TABLES

*&---------------------------------------------------------------------*
*& Report zinternaltab_steb
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zinternaltab_steb.
*** Internal Tables ***
*** Declaration using your own internal type ***
TYPES: BEGIN OF ty_person,
        fname(25) TYPE c,
        lname(25) TYPE c,
        dob       TYPE d,
        "... you get the idea ..."
       END OF ty_person.

DATA:   ls_person1 TYPE ty_person,
        lt_person1 TYPE TABLE OF ty_person.
*** Internal Tables ***
*** Filling the internal structure with data
ls_person1-fname = 'Bob'.
ls_person1-lname = 'McBoss'.
ls_person1-dob   = sy-datum.
*** Appending data from the structure to the internal table
APPEND ls_person1 TO lt_person1.

ls_person1-fname = 'Alice'.
ls_person1-lname = 'Doe'.
ls_person1-dob   = sy-datum.
APPEND ls_person1 TO lt_person1.

ls_person1-fname = 'John'.
ls_person1-lname = 'Doe'.
ls_person1-dob   = sy-datum.
APPEND ls_person1 TO lt_person1.
*** Internal Tables ***
DATA: lt_person2 TYPE TABLE OF ty_person.
*** Filling the internal structure using a different approach
 lt_person2 = VALUE #( ( fname = 'Alice' lname = 'Doe' dob   = sy-datum )
                       ( fname = 'Bob'   lname = 'Doe' dob   = sy-datum )
                       ( fname = 'Fil'   lname = 'BigBoss' dob   = sy-datum ) ).

*** Sorting internal tables
SORT lt_person2 BY lname ASCENDING."<-specify sorting fields after 'BY'
                                    "< sorting order 'ASCENDING' or 'DESCENDING





INTERNAL TABLE 2


*&---------------------------------------------------------------------*
*& Report zinternaltab_steb
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zinternaltab_steb.

*** Internal Tables ***
*** Declaration using your own internal type ***
TYPES: BEGIN OF ty_person,
        fname(25) TYPE c,
        lname(25) TYPE c,
        dob       TYPE d,
       END OF ty_person.

DATA:   ls_person1 TYPE ty_person,
        lt_person1 TYPE TABLE OF ty_person.

*** Filling the internal structure with data ***
ls_person1-fname = 'Bob'.
ls_person1-lname = 'McBoss'.
ls_person1-dob   = sy-datum.
*** Appending data from the structure to the internal table ***
APPEND ls_person1 TO lt_person1.

ls_person1-fname = 'Alice'.
ls_person1-lname = 'Doe'.
ls_person1-dob   = sy-datum.
APPEND ls_person1 TO lt_person1.

ls_person1-fname = 'John'.
ls_person1-lname = 'Doe'.
ls_person1-dob   = sy-datum.
APPEND ls_person1 TO lt_person1.

*** Internal Tables ***
DATA: lt_person2 TYPE TABLE OF ty_person.

*** Filling the internal structure using a different approach ***
lt_person2 = VALUE #( ( fname = 'Alice' lname = 'Doe' dob   = sy-datum )
                      ( fname = 'Bob'   lname = 'Doe' dob   = sy-datum )
                      ( fname = 'Fil'   lname = 'BigBoss' dob   = sy-datum ) ).

*** Sorting internal tables ***
SORT lt_person2 BY lname ASCENDING. "Specify sorting fields after 'BY' and sorting order 'ASCENDING' or 'DESCENDING'

*** Internal table processing with LOOP ***
DATA: ls_person2 TYPE ty_person. " Declare the structure to hold loop data

LOOP AT lt_person2 INTO ls_person2. "Table lines loaded into structure one by one
    WRITE: / |Table line: { sy-tabix }|,                                      "table index output
           / |{ ls_person2-fname }  { ls_person2-lname }  { ls_person2-dob }|. "data output
    SKIP 1.                                                                   "empty line
ENDLOOP.

*** Same thing using field-symbols (pointers in ABAP) ***
*** Field symbol points at one line of the table in each iteration ***
FIELD-SYMBOLS: <fs_person> TYPE ty_person. " Declare field-symbol only once

LOOP AT lt_person2 ASSIGNING <fs_person>.
    WRITE: / |Table line: { sy-tabix }|,                                        "table index output
           / |{ <fs_person>-fname } { <fs_person>-lname } { <fs_person>-dob }|. "data output
    SKIP 1.                                                                     "empty line
ENDLOOP.





















DIFFERENCE BETWEEN INTERNAL TABLE AND TABLE FROM SAP DATA DICTIONARY (DB TABLES)?
ANSWER:
- INTERNAL TABLES: TEMPORARY, IN-MEMORY, USED FOR PROCESSING DATA WITHIN PROGRAMS.
- DATABASE TABLES: PERMANENT, STORED IN THE DATABASE, USED FOR STORING PERSISTENT APPLICATION DATA.



















TASK 
During the “SAP Data Dictionary” topic you have created a DB table.
Create new ABAP program in a following way:
	Declare internal table using your DB table.
	Populate the internal table with data.
	Read and display one record with the most recent Production date.
	Display all the data.
	It is a good idea to free the memory when writing big programs with complex logic. Imagine that your program is big and complex, find out how to free the memory used for internal table and how to un-assign field symbols.
ANSWER


*&---------------------------------------------------------------------*
*& Report zinternaltabletask_steb
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zinternaltabletask_steb.

* Define the structure of the internal table
TYPES: BEGIN OF ty_plane_data,
         mandt      TYPE ztsaplane_steb-mandt,
         planetype  TYPE ztsaplane_steb-planetype,
         dats       TYPE ztsaplane_steb-dats,
         type       TYPE ztsaplane_steb-type,
         countr     TYPE ztsaplane_steb-countr,
         engt       TYPE ztsaplane_steb-engt,
         fus        TYPE ztsaplane_steb-fus,
         note       TYPE ztsaplane_steb-note,
       END OF ty_plane_data.

* Declare the internal table and work area
DATA: it_plane_data TYPE TABLE OF ty_plane_data,
      wa_plane_data TYPE ty_plane_data.

* Select data from the database table
SELECT mandt
       planetype
       dats
       type
       countr
       engt
       fus
       note
  INTO TABLE it_plane_data
  FROM ztsaplane_steb.

* Sort the internal table by date in descending order
SORT it_plane_data BY dats DESCENDING.

* Read the first entry (most recent date)
READ TABLE it_plane_data INTO wa_plane_data INDEX 1.

* Display the most recent record
WRITE: / 'Most Recent Production Record:',
       / 'Client:', wa_plane_data-mandt,
       / 'Plane Type:', wa_plane_data-planetype,
       / 'Date:', wa_plane_data-dats,
       / 'Type:', wa_plane_data-type,
       / 'Country:', wa_plane_data-countr,
       / 'Engine Type:', wa_plane_data-engt,
       / 'Fuselage Characteristics:', wa_plane_data-fus,
       / 'Notes:', wa_plane_data-note.

* Loop through the internal table and display each record
LOOP AT it_plane_data INTO wa_plane_data.
  WRITE: / 'Client:', wa_plane_data-mandt,
         / 'Plane Type:', wa_plane_data-planetype,
         / 'Date:', wa_plane_data-dats,
         / 'Type:', wa_plane_data-type,
         / 'Country:', wa_plane_data-countr,
         / 'Engine Type:', wa_plane_data-engt,
         / 'Fuselage Characteristics:', wa_plane_data-fus,
         / 'Notes:', wa_plane_data-note.
ENDLOOP.

* Free the memory used by the internal table
FREE it_plane_data.








SQL SELECT STATEMENT


 Declarations 
DATA: lt_sflight TYPE TABLE OF sflight, "<--- internal table for sflight data
      ls_sflight TYPE sflight.          "<--- work area for a single sflight row

*** Select all fields from sflight into internal table lt_sflight ***
SELECT *
    FROM sflight
    INTO TABLE lt_sflight.

IF sy-subrc = 0.                "<--- check if the select was successful
    "some code here
ENDIF.

*** Inline declaration and select from spfli ***
SELECT *
    FROM spfli
    INTO TABLE @DATA(lt_spfli). "<--- inline declared internal table lt_spfli

*** Select specific fields from scarr ***
SELECT carrid,
       carrname
    FROM scarr
    INTO TABLE @DATA(lt_scarr). "<--- inline declared internal table lt_scarr

*** Select a single row into work area ls_sflight ***
SELECT SINGLE *
    FROM sflight
    INTO ls_sflight. "<--- target structure

WRITE: / |{ ls_sflight-carrid } { ls_sflight-connid } { ls_sflight-fldate }|.
SKIP 1.

*** Loop through all rows in sflight and write specific fields ***
SELECT *
    FROM sflight
    INTO ls_sflight. "<--- target structure
    WRITE: / |{ ls_sflight-carrid } { ls_sflight-connid } { ls_sflight-fldate }|.
ENDSELECT.

*** Selection screen with parameters and select-options ***
TABLES: sflight. "<--- required for select options

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-001. "<--- block b1 with title
    PARAMETERS: p_carrid TYPE sflight-carrid, "<--- parameter for carrier ID
                p_connid TYPE sflight-connid. "<--- parameter for connection ID
SELECTION-SCREEN END OF BLOCK b1.

SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE text-002. "<--- block b2 with title
    SELECT-OPTIONS: s_fldate FOR sflight-fldate DEFAULT sy-datum. "<--- select-option for flight date
SELECTION-SCREEN END OF BLOCK b2.

*** Corrected select with conditions using parameters and select-options ***
SELECT *
    FROM sflight
    INTO TABLE @lt_sflight "<--- pre-declared internal table
    WHERE carrid = @p_carrid    "<--- using parameter p_carrid
      AND connid = @p_connid    "<--- using parameter p_connid
      AND fldate IN @s_fldate.  "<--- using select-option s_fldate





















TASK

TRY THESE OUT WITH INLINE TARGET DECLARATION AND WITH SPECIFIC FIELDS
SELECT carrid, connid, fldate
    FROM sflight
    INTO TABLE @DATA(lt_sflight_specific).
    SELECT SINGLE carrid, connid, fldate
    FROM sflight
    INTO @DATA(ls_sflight_single).
WRITE: / |{ ls_sflight_single-carrid } { ls_sflight_single-connid } { ls_sflight_single-fldate }|.
SELECT carrid, connid, fldate
    FROM sflight
    INTO @DATA(ls_sflight).
    WRITE: / |{ ls_sflight-carrid } { ls_sflight-connid } { ls_sflight-fldate }|.
ENDSELECT.

*** WRITE THE SAME SELECT USING REGULAR INTERNAL TABLE DECLARATION ***
REPORT ztest_steb.

DATA: lt_scarr TYPE TABLE OF scarr.

SELECT carrid,
       carrname
    FROM scarr
    INTO TABLE @lt_scarr.

TASK 
Write a program with the following specifications:
	Requirement is to get data and display from table SPFLI table - get Airline Code, Flight Connection Number, Departure city, Departure airport, Arrival city, Destination airport, Flight time, Distance.
	Program should have parameter input for Airline Codes and selection-options parameter for Flight Connection Numbers.
	SELECT based on the user input in the selection screen.


ANSWER

TABLES: spfli.

DATA: it_spfli TYPE STANDARD TABLE OF spfli,
      wa_spfli TYPE spfli.

* Selection screen
PARAMETERS: p_carrid TYPE spfli-carrid OBLIGATORY.

SELECT-OPTIONS: s_connid FOR spfli-connid.

START-OF-SELECTION.

* Select data from SPFLI table based on user input
SELECT carrid
       connid
       cityfrom
       airpfrom
       cityto
       airpto
       fltime
       distance
  INTO CORRESPONDING FIELDS OF TABLE it_spfli
  FROM spfli
  WHERE carrid = p_carrid
    AND connid IN s_connid.

* Check if data exists
IF it_spfli[] IS INITIAL.
  WRITE: 'No data found for the given criteria.'.
  EXIT.
ENDIF.

* Display the fetched data
LOOP AT it_spfli INTO wa_spfli.
  WRITE: / 'Airline Code: ', wa_spfli-carrid,
         'Connection Number: ', wa_spfli-connid,
         'Departure City: ', wa_spfli-cityfrom,
         'Departure Airport: ', wa_spfli-airpfrom,
         'Arrival City: ', wa_spfli-cityto,
         'Destination Airport: ', wa_spfli-airpto,
         'Flight Time: ', wa_spfli-fltime,
         'Distance: ', wa_spfli-distance.
ENDLOOP.

CREATE A PROGRAM THAT CAN INSERT, UPDATE AND MODIFY YOUR DB TABLE FROM THE ‘SAP DATA DICTIONARY’ TOPIC.
	INPUT PARAMETERS ON THE SELECTION SCREEN TO FILL THE STRUCTURE WITH DATA.
	RADIO BUTTON GROUP TO DETERMINE ACTION (INSERT / UPDATE / MODIFY).
	ERROR HANDLING WITH MESSAGES (CHECKING SY-SUBRC VALUE).
	EXPLORE THE DIFFERENCES IN THE WAY THESE OPERATIONS WORK.
	INSERT ~10 RECORDS FOR FURTHER TASKS.



TABLES: ztsaplane_steb.

PARAMETERS: p_id TYPE zde_countr_steb,
            p_name TYPE zde_engt_steb,
            p_age TYPE zde_fus_steb,
            p_note TYPE zde_note_steb,
            p_type TYPE zde_type_steb.

SELECTION-SCREEN BEGIN OF BLOCK rad1.
PARAMETERS: r_insert RADIOBUTTON GROUP rad1 DEFAULT 'X',
            r_update RADIOBUTTON GROUP rad1,
            r_modify RADIOBUTTON GROUP rad1.
SELECTION-SCREEN END OF BLOCK rad1.

START-OF-SELECTION.

  IF r_insert = abap_true.
    PERFORM insert_data.
  ELSEIF r_update = abap_true.
    PERFORM update_data.
  ELSEIF r_modify = abap_true.
    PERFORM modify_data.
  ENDIF.

  PERFORM display_results.

END-OF-SELECTION.

FORM insert_data.
  CLEAR ztsaplane_steb.
  ztsaplane_steb-countr = p_id.
  ztsaplane_steb-engt = p_name.
  ztsaplane_steb-fus = p_age.
  ztsaplane_steb-note = p_note.
  ztsaplane_steb-type = p_type.
  INSERT INTO ztsaplane_steb VALUES ztsaplane_steb.
  IF sy-subrc = 0.
    WRITE: / 'Record inserted successfully.'.
  ELSE.
    WRITE: / 'Error inserting record.'.
  ENDIF.
ENDFORM.

FORM update_data.
  SELECT SINGLE * FROM ztsaplane_steb WHERE countr = @p_id INTO @ztsaplane_steb.
  IF sy-subrc = 0.
    ztsaplane_steb-engt = p_name.
    ztsaplane_steb-fus = p_age.
    ztsaplane_steb-note = p_note.
    ztsaplane_steb-type = p_type.
    UPDATE ztsaplane_steb SET engt = @ztsaplane_steb-engt,
                              fus = @ztsaplane_steb-fus,
                              note = @ztsaplane_steb-note,
                              type = @ztsaplane_steb-type
    WHERE countr = @p_id.
    IF sy-subrc = 0.
      WRITE: / 'Record updated successfully.'.
    ELSE.
      WRITE: / 'Error updating record.'.
    ENDIF.
  ELSE.
    WRITE: / 'Record not found.'.
  ENDIF.
ENDFORM.

FORM modify_data.
  SELECT SINGLE * FROM ztsaplane_steb WHERE countr = @p_id INTO @ztsaplane_steb.
  IF sy-subrc = 0.
    IF p_name IS NOT INITIAL.
      ztsaplane_steb-engt = p_name.
    ENDIF.
    IF p_age IS NOT INITIAL.
      ztsaplane_steb-fus = p_age.
    ENDIF.
    IF p_note IS NOT INITIAL.
      ztsaplane_steb-note = p_note.
    ENDIF.
    IF p_type IS NOT INITIAL.
      ztsaplane_steb-type = p_type.
    ENDIF.
    UPDATE ztsaplane_steb SET engt = @ztsaplane_steb-engt,
                              fus = @ztsaplane_steb-fus,
                              note = @ztsaplane_steb-note,
                              type = @ztsaplane_steb-type
    WHERE countr = @p_id.
    IF sy-subrc = 0.
      WRITE: / 'Record modified successfully.'.
    ELSE.
      WRITE: / 'Error modifying record.'.
    ENDIF.
  ELSE.
    WRITE: / 'Record not found.'.
  ENDIF.
ENDFORM.

FORM display_results.
  DATA: lt_result TYPE TABLE OF ztsaplane_steb.

SELECT * FROM ztsaplane_steb INTO TABLE @lt_result.
IF sy-subrc = 0.
  LOOP AT lt_result INTO DATA(ls_row).
    WRITE: / ls_row-countr, ls_row-engt, ls_row-fus, ls_row-note, ls_row-type.
  ENDLOOP.
ELSE.
  WRITE: / 'No records found in the table.'.
ENDIF.
ENDFORM.

FORM insert_initial_data.
  DATA: lt_data TYPE TABLE OF ztsaplane_steb,
        ls_data TYPE ztsaplane_steb.

  CLEAR: ls_data.
  ls_data-countr = 'US'. ls_data-engt = 'Engine1'. ls_data-fus = 'Fuselage1'. ls_data-note = 'Note1'. ls_data-type = 'Type1'. APPEND ls_data TO lt_data.
  ls_data-countr = 'DE'. ls_data-engt = 'Engine2'. ls_data-fus = 'Fuselage2'. ls_data-note = 'Note2'. ls_data-type = 'Type2'. APPEND ls_data TO lt_data.
  ls_data-countr = 'FR'. ls_data-engt = 'Engine3'. ls_data-fus = 'Fuselage3'. ls_data-note = 'Note3'. ls_data-type = 'Type3'. APPEND ls_data TO lt_data.
  ls_data-countr = 'JP'. ls_data-engt = 'Engine4'. ls_data-fus = 'Fuselage4'. ls_data-note = 'Note4'. ls_data-type = 'Type4'. APPEND ls_data TO lt_data.
  ls_data-countr = 'UK'. ls_data-engt = 'Engine5'. ls_data-fus = 'Fuselage5'. ls_data-note = 'Note5'. ls_data-type = 'Type5'. APPEND ls_data TO lt_data.

  LOOP AT lt_data INTO ls_data.
    MOVE-CORRESPONDING ls_data TO ztsaplane_steb.
    INSERT ztsaplane_steb.
    IF sy-subrc = 0.
      WRITE: / 'Record with COUNTR', ztsaplane_steb-countr, 'inserted successfully.'.
    ELSE.
      WRITE: / 'Error inserting record with COUNTR', ztsaplane_steb-countr.
    ENDIF.
  ENDLOOP.
ENDFORM.






















OPEN YOUR CALCULATOR PROGRAM FROM DAY 2 AND MODIFY IT:
ENCAPSULATE THE CODE FOR ARITHMETIC OPERATIONS IN SUBROUTINES


SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-001.
PARAMETERS: p_num1 TYPE i,
            p_num2 TYPE i.
SELECTION-SCREEN END OF BLOCK b1.

DATA: result TYPE i.

START-OF-SELECTION.

  PERFORM add USING p_num1 p_num2 CHANGING result.
  WRITE: / 'First Number:' , p_num1 ,
         / 'Second Number:' , p_num2 ,
         / 'Sum: ', result.

  PERFORM subtract USING p_num1 p_num2 CHANGING result.
  WRITE: / 'Difference: ', result.

  PERFORM multiply USING p_num1 p_num2 CHANGING result.
  WRITE: / 'Product: ', result.

  PERFORM divide USING p_num1 p_num2 CHANGING result.
  WRITE: / 'Quotient: ', result.

*--------------------------------------------------------------------*
*       FORM add
*--------------------------------------------------------------------*
FORM add USING num1 TYPE i
              num2 TYPE i
         CHANGING res TYPE i.
  res = num1 + num2.
ENDFORM.                    " add
*--------------------------------------------------------------------*
*       FORM subtract
*--------------------------------------------------------------------*
FORM subtract USING num1 TYPE i
                   num2 TYPE i
              CHANGING res TYPE i.
  res = num1 - num2.
ENDFORM.                    " subtract
*--------------------------------------------------------------------*
*       FORM multiply
*--------------------------------------------------------------------*
FORM multiply USING num1 TYPE i
                   num2 TYPE i
              CHANGING res TYPE i.
  res = num1 * num2.
ENDFORM.                    " multiply
*--------------------------------------------------------------------*
*       FORM divide
*--------------------------------------------------------------------*
FORM divide USING num1 TYPE i
                 num2 TYPE i
            CHANGING res TYPE i.
  IF num2 = 0.
    WRITE: / 'Error: Cannot divide by zero!'.
    res = 0.
  ELSE.
    res = num1 / num2.
  ENDIF.
ENDFORM.                    " divide


















TASK 
CREATE NEW FM BASED ON THE PREVIOUS EXAMPLE WITH THE FOLLOWING MODIFICATIONS:
	IMPORT PARAMETER FOR DEGREES
	IMPORT PARAMETER TO DEFINE THE SCALE OF THE INPUT DEGREES (CELSIUS, FAHRENHEIT, KELVIN)
	IMPORT PARAMETER TO DEFINE THE SCALE OF THE OUTPUT DEGREES (WHAT ARE WE CONVERTING TO)
	EXPORT – RESULT OF THE CONVERSION
	*EXCEPTION HANDLING IF USER HAD ENTERED SAME INPUT AND OUTPUT SCALES
	CREATE A PROGRAM WITH SELECTION SCREEN TO INPUT PARAMETERS
	CALL THE FM FROM PROGRAM
	GIVE THE OUTPUT OF THE FM TO THE SCREEN

SAP LOGON CODE:

FUNCTION Z_CONVERT_TEMPERATURE.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(IV_DEGREES) TYPE  FLOAT
*"     VALUE(IV_INPUT_SCALE) TYPE  CHAR3
*"     VALUE(IV_OUTPUT_SCALE) TYPE  CHAR3
*"  EXPORTING
*"     VALUE(EV_RESULT) TYPE  FLOAT
*"  EXCEPTIONS
*"      SAME_SCALE
*"----------------------------------------------------------------------

  " Exception if input and output scales are the same
  IF IV_INPUT_SCALE EQ IV_OUTPUT_SCALE.
    RAISE SAME_SCALE.
  ENDIF.

  " Convert input scale to Celsius
  DATA: lv_degrees_c TYPE FLOAT.
  CASE IV_INPUT_SCALE.
    WHEN 'C'.
      lv_degrees_c = IV_DEGREES.
    WHEN 'F'.
      lv_degrees_c = (IV_DEGREES - 32) * 5 / 9.
    WHEN 'K'.
      lv_degrees_c = IV_DEGREES - 273.15.
    WHEN OTHERS.
      RAISE SAME_SCALE.
  ENDCASE.

  " Convert from Celsius to output scale
  CASE IV_OUTPUT_SCALE.
    WHEN 'C'.
      EV_RESULT = lv_degrees_c.
    WHEN 'F'.
      EV_RESULT = (lv_degrees_c * 9 / 5) + 32.
    WHEN 'K'.
      EV_RESULT = lv_degrees_c + 273.15.
    WHEN OTHERS.
      RAISE SAME_SCALE.
  ENDCASE.

ENDFUNCTION.


OTHER CODE




FUNCTION Z_FM_CONVERT_TEMP_STEB.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IM_DEGREES) TYPE  F
*"     REFERENCE(IM_INPUT_SCALE) TYPE  CHAR3
*"     REFERENCE(IM_OUTPUT_SCALE) TYPE  CHAR3
*"  EXPORTING
*"     REFERENCE(EX_RESULT) TYPE  F
*"  EXCEPTIONS
*"      INVALID_INPUT_SCALE
*"      INVALID_OUTPUT_SCALE
*"      SAME_INPUT_OUTPUT_SCALE
*"----------------------------------------------------------------------
  DATA: lv_celsius TYPE f.

  " Exception handling for same input and output scales
  IF im_input_scale = im_output_scale.
    RAISE SAME_INPUT_OUTPUT_SCALE.
  ENDIF.

  " Convert input to Celsius first
  CASE im_input_scale.
    WHEN 'CEL'.
      lv_celsius = im_degrees.
    WHEN 'FAH'.
      lv_celsius = ( im_degrees - 32 ) * 5 / 9.
    WHEN 'KEL'.
      lv_celsius = im_degrees - 273.15.
    WHEN OTHERS.
      RAISE INVALID_INPUT_SCALE.
  ENDCASE.

  " Convert Celsius to output scale
  CASE im_output_scale.
    WHEN 'CEL'.
      ex_result = lv_celsius.
    WHEN 'FAH'.
      ex_result = lv_celsius * 9 / 5 + 32.
    WHEN 'KEL'.
      ex_result = lv_celsius + 273.15.
    WHEN OTHERS.
      RAISE INVALID_OUTPUT_SCALE.
  ENDCASE.


ENDFUNCTION.




ECLIPSE CODE:


*&---------------------------------------------------------------------*
*& Report Z_TEMP_CONVERSION_STEB
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT Z_TEMP_CONVERSION_STEB.

PARAMETERS: p_cels TYPE p DECIMALS 2,
            p_fahr TYPE p DECIMALS 2.

DATA: v_fahr TYPE p DECIMALS 2,
      v_cels TYPE p DECIMALS 2.

v_fahr = ( p_cels * 9 / 5 ) + 32.
v_cels = ( p_fahr - 32 ) * 5 / 9.

WRITE: / 'Celsius to Fahrenheit:', p_cels, 'C =', v_fahr, 'F',
       / 'Fahrenheit to Celsius:', p_fahr, 'F =', v_cels, 'C'.











Function Modules (Exercise 3) 
Create a function module in SAP GUI for your calculator program and encapsulate arithmetical operations within it (skip the function group creation part, as you have already created one – use it here as well).
	Call the FM from your calculator program.
	Exception handling for division by zero
























ALV



*** Internal table declaration ***
DATA: lt_plane_data TYPE TABLE OF ztsaplane_steb.

*** Select data from the database table ***
SELECT * FROM ztsaplane_steb INTO TABLE lt_plane_data.

*** Field catalog declaration ***
DATA: lt_fieldcat TYPE slis_t_fieldcat_alv.

*** Field catalog population ***
lt_fieldcat = VALUE #( 
  ( fieldname = 'MANDT'     seltext_l = 'Client' )
  ( fieldname = 'PLANETYPE' seltext_l = 'Aircraft Type' )
  ( fieldname = 'DATS'      seltext_l = 'Date' )
  ( fieldname = 'TYPE'      seltext_l = 'Type' )
  ( fieldname = 'COUNTR'    seltext_l = 'Production Country' )
  ( fieldname = 'ENGT'      seltext_l = 'Engine Type' )
  ( fieldname = 'FUS'       seltext_l = 'Fuselage Characteristics' )
  ( fieldname = 'NOTE'      seltext_l = 'Notes' )
).

*** ALV ***
*** Calling ALV Grid ***
CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
  EXPORTING
    IT_FIELDCAT                       = lt_fieldcat  "populated field catalog
  TABLES
    t_outtab                          = lt_plane_data  "internal table with data
  EXCEPTIONS
    PROGRAM_ERROR                     = 1
    OTHERS                            = 2.

IF sy-subrc <> 0.
  WRITE: / 'Error in REUSE_ALV_GRID_DISPLAY'.
  EXIT.
ENDIF.

















MODIFY YOUR PROGRAM FROM THE TOPIC ABOUT SQL, THAT DOES OPERATIONS ON YOUR DB TABLE:
	ADD RADIO BUTTON ‘DISPLAY’
	IMPLEMENT ALV LOGIC TO DISPLAY THE DB TABLE DATA
	EXPLORE AND EXPERIMENT WITH THE FIELDS OF FIELD CATALOG (AFTER YOU HAVE MANAGED TO DISPLAY THE DATA)



REPORT zdisplay_alv_steb

TABLES: ztsaplane_steb.

TYPES: 
  BEGIN OF ty_plane,
    mandt     TYPE ztsaplane_steb-mandt,
    planetype TYPE ztsaplane_steb-planetype,
    dats      TYPE ztsaplane_steb-dats,
    type      TYPE ztsaplane_steb-type,
    countr    TYPE ztsaplane_steb-countr,
    engt      TYPE ztsaplane_steb-engt,
    fus       TYPE ztsaplane_steb-fus,
    note      TYPE ztsaplane_steb-note,
  END OF ty_plane.

DATA: 
  lt_plane_data TYPE TABLE OF ty_plane,
  lt_fieldcat   TYPE slis_t_fieldcat_alv,
  ls_fieldcat   TYPE slis_fieldcat_alv.

PARAMETERS: 
  p_disp1 TYPE c RADIOBUTTON GROUP rad1 DEFAULT 'X',
  p_disp2 TYPE c RADIOBUTTON GROUP rad1.

START-OF-SELECTION.
  IF p_disp1 = 'X'.
    SELECT mandt
           planetype
           dats
           type
           countr
           engt
           fus
           note
      FROM ztsaplane_steb
      INTO TABLE lt_plane_data.
  ENDIF.

  CLEAR: lt_fieldcat, ls_fieldcat.

  ls_fieldcat-fieldname = 'MANDT'.
  ls_fieldcat-seltext_l = 'Client'.
  ls_fieldcat-outputlen = 10.
  ls_fieldcat-col_pos   = 1.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'PLANETYPE'.
  ls_fieldcat-seltext_l = 'Aircraft Type'.
  ls_fieldcat-outputlen = 20.
  ls_fieldcat-col_pos   = 2.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'DATS'.
  ls_fieldcat-seltext_l = 'Date'.
  ls_fieldcat-outputlen = 10.
  ls_fieldcat-col_pos   = 3.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'TYPE'.
  ls_fieldcat-seltext_l = 'Type'.
  ls_fieldcat-outputlen = 15.
  ls_fieldcat-col_pos   = 4.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'COUNTR'.
  ls_fieldcat-seltext_l = 'Production Country'.
  ls_fieldcat-outputlen = 20.
  ls_fieldcat-col_pos   = 5.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'ENGT'.
  ls_fieldcat-seltext_l = 'Engine Type'.
  ls_fieldcat-outputlen = 15.
  ls_fieldcat-col_pos   = 6.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'FUS'.
  ls_fieldcat-seltext_l = 'Fuselage Characteristics'.
  ls_fieldcat-outputlen = 25.
  ls_fieldcat-col_pos   = 7.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'NOTE'.
  ls_fieldcat-seltext_l = 'Notes'.
  ls_fieldcat-outputlen = 30.
  ls_fieldcat-col_pos   = 8.
  APPEND ls_fieldcat TO lt_fieldcat.

  CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
    EXPORTING
      it_fieldcat = lt_fieldcat
    TABLES
      t_outtab    = lt_plane_data
    EXCEPTIONS
      program_error = 1
      OTHERS        = 2.

  IF sy-subrc <> 0.
    WRITE: / 'Error in REUSE_ALV_GRID_DISPLAY'.
  ENDIF.


ALV



REPORT ztest_steb.

*** ALV ***
*** Extended functionality examples ***
*** IS_LAYOUT  (slis_layout_alv) - List layout specifications ***
*** IS_VARIANT (disvariant)      - Variant information ***
*** I_SAVE                       - Variant saving options ***
*** I_SAVE = SPACE  Layouts cannot be saved.
*** I_SAVE = 'U'    Only user-defined layouts can be saved.
*** I_SAVE = 'X'    Only global layouts can be saved.
*** I_SAVE = 'A'    Both user-defined and global layouts can be saved.
DATA: ls_layout  TYPE slis_layout_alv,
      ls_variant TYPE disvariant,
      lt_fieldcat TYPE TABLE OF slis_fieldcat_alv,
      lt_prod     TYPE TABLE OF sflight. "<-- SFLIGHT tablosunun satır türü

*** Fill field catalog (lt_fieldcat) ***
PERFORM fill_field_catalog CHANGING lt_fieldcat.

*** Fill internal table (lt_prod) ***
SELECT * FROM sflight INTO TABLE lt_prod.

ls_layout-colwidth_optimize = 'X'. "<--- adjusted column width to the data it has
ls_layout-zebra = 'X'.             "<--- colored rows for easier navigation
ls_variant-report = sy-repid.      "<--- minimal required field for using variants

CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
    EXPORTING
      IS_LAYOUT   = ls_layout
      I_SAVE      = 'A'
      IS_VARIANT  = ls_variant
      IT_FIELDCAT = lt_fieldcat
    TABLES
      t_outtab    = lt_prod
    EXCEPTIONS
      PROGRAM_ERROR = 1
      OTHERS        = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

FORM fill_field_catalog CHANGING p_fieldcat TYPE slis_t_fieldcat_alv.
  DATA: ls_fieldcat TYPE slis_fieldcat_alv.

  CLEAR ls_fieldcat.
  ls_fieldcat-fieldname = 'CARRID'. "<-- Replace with your actual field name
  ls_fieldcat-seltext_m = 'Carrier ID'. "<-- Replace with your field description
  APPEND ls_fieldcat TO p_fieldcat.

  CLEAR ls_fieldcat.
  ls_fieldcat-fieldname = 'CONNID'. "<-- Replace with your actual field name
  ls_fieldcat-seltext_m = 'Connection ID'. "<-- Replace with your field description
  APPEND ls_fieldcat TO p_fieldcat.

  " Add more fields as necessary
ENDFORM.























EXPLORE OPTIONS OF USING LAYOUT AND VARIANT SETTINGS FOR ALV. EXTEND YOUR PROGRAM WITH THESE ADDITIONS.



REPORT z_display_alv_steb.

TABLES: ztsaplane_steb.

TYPES:
  BEGIN OF ty_plane,
    mandt     TYPE ztsaplane_steb-mandt,
    planetype TYPE ztsaplane_steb-planetype,
    dats      TYPE ztsaplane_steb-dats,
    type      TYPE ztsaplane_steb-type,
    countr    TYPE ztsaplane_steb-countr,
    engt      TYPE ztsaplane_steb-engt,
    fus       TYPE ztsaplane_steb-fus,
    note      TYPE ztsaplane_steb-note,
  END OF ty_plane.

DATA:
  lt_plane_data TYPE TABLE OF ty_plane,
  lt_fieldcat   TYPE slis_t_fieldcat_alv,
  ls_fieldcat   TYPE slis_fieldcat_alv.

DATA:
  gs_layout     TYPE slis_layout_alv,
  gt_variant    TYPE disvariant,
  gs_variant    TYPE disvariant.

PARAMETERS:
  p_disp1 TYPE c RADIOBUTTON GROUP rad1 DEFAULT 'X',
  p_disp2 TYPE c RADIOBUTTON GROUP rad1.

SELECT-OPTIONS:
  s_var FOR gs_variant-variant.

INITIALIZATION.
  CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
    EXPORTING
      i_save     = 'A'
    CHANGING
      cs_variant = gs_variant
    EXCEPTIONS
      OTHERS     = 1.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR s_var-low.
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gs_variant
    CHANGING
      cs_variant = gs_variant
    EXCEPTIONS
      OTHERS     = 1.

START-OF-SELECTION.
  IF p_disp1 = 'X'.
    SELECT mandt
           planetype
           dats
           type
           countr
           engt
           fus
           note
      FROM ztsaplane_steb
      INTO TABLE lt_plane_data.
  ENDIF.

  CLEAR: lt_fieldcat, ls_fieldcat.

  ls_fieldcat-fieldname = 'MANDT'.
  ls_fieldcat-seltext_l = 'Client'.
  ls_fieldcat-outputlen = 10.
  ls_fieldcat-col_pos   = 1.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'PLANETYPE'.
  ls_fieldcat-seltext_l = 'Aircraft Type'.
  ls_fieldcat-outputlen = 20.
  ls_fieldcat-col_pos   = 2.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'DATS'.
  ls_fieldcat-seltext_l = 'Date'.
  ls_fieldcat-outputlen = 10.
  ls_fieldcat-col_pos   = 3.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'TYPE'.
  ls_fieldcat-seltext_l = 'Type'.
  ls_fieldcat-outputlen = 15.
  ls_fieldcat-col_pos   = 4.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'COUNTR'.
  ls_fieldcat-seltext_l = 'Production Country'.
  ls_fieldcat-outputlen = 20.
  ls_fieldcat-col_pos   = 5.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'ENGT'.
  ls_fieldcat-seltext_l = 'Engine Type'.
  ls_fieldcat-outputlen = 15.
  ls_fieldcat-col_pos   = 6.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'FUS'.
  ls_fieldcat-seltext_l = 'Fuselage Characteristics'.
  ls_fieldcat-outputlen = 25.
  ls_fieldcat-col_pos   = 7.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = 'NOTE'.
  ls_fieldcat-seltext_l = 'Notes'.
  ls_fieldcat-outputlen = 30.
  ls_fieldcat-col_pos   = 8.
  APPEND ls_fieldcat TO lt_fieldcat.

  gs_layout-zebra = 'X'.
  gs_layout-colwidth_optimize = 'X'.

  gs_variant-report = sy-repid.

  CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
    EXPORTING
      it_fieldcat   = lt_fieldcat
      is_layout     = gs_layout
      i_save        = 'A'
      is_variant    = gs_variant
    TABLES
      t_outtab      = lt_plane_data
    EXCEPTIONS
      program_error = 1
      OTHERS        = 2.

  IF sy-subrc <> 0.
    WRITE: / 'Error in REUSE_ALV_GRID_DISPLAY'.
  ENDIF.

























Excercise 1:
Overview:
Make a Function Group consisting of function modules that can:
•	Accept 3 integers between 0 to 100 (Import Parameters ONLY)
•	Add integers 1&2 and 2&3 (Export Parameters ONLY, use input from 1st FM)
•	Subtract integers 1&2 and 2&3 (Export Parameters ONLY, use input from 1st FM)
Actions:
1.	Create a report that accepts 3 integers
2.	Then calls all 3 FMs above
3.	Display results


REPORT Z_REPORT_DISPLAY_RESULTS_STEB.

PARAMETERS: p_int1 TYPE i,
            p_int2 TYPE i,
            p_int3 TYPE i.

DATA: lv_result1 TYPE i,
      lv_result2 TYPE i,
      lv_result3 TYPE i,
      lv_add1_2  TYPE i,
      lv_add2_3  TYPE i,
      lv_sub1_2  TYPE i,
      lv_sub2_3  TYPE i.

CALL FUNCTION 'Z_ACCEPT_THREE_INTEGERS_STEB'
  EXPORTING
    int1 = p_int1
    int2 = p_int2
    int3 = p_int3
  IMPORTING
    result1 = lv_result1
    result2 = lv_result2
    result3 = lv_result3.

CALL FUNCTION 'Z_ADD_INTEGERS_STEB'
  EXPORTING
    int1 = lv_result1
    int2 = lv_result2
    int3 = lv_result3
  IMPORTING
    add1_2 = lv_add1_2
    add2_3 = lv_add2_3.

CALL FUNCTION 'Z_SUBTRACT_INTEGERS_STEB'
  EXPORTING
    int1 = lv_result1
    int2 = lv_result2
    int3 = lv_result3
  IMPORTING
    sub1_2 = lv_sub1_2
    sub2_3 = lv_sub2_3.

WRITE: / 'Addition of Integer 1 and Integer 2:', lv_add1_2,
       / 'Addition of Integer 2 and Integer 3:', lv_add2_3,
       / 'Subtraction of Integer 1 and Integer 2:', lv_sub1_2,
       / 'Subtraction of Integer 2 and Integer 3:', lv_sub2_3.


  
